<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.13.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="../../logo_arcane.svg" type="image/svg+xml">
    <title>Arcane: Référence de la classe Arcane::IMeshUtilities</title>
    <link href="../../tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="../../jquery.js"></script>
    <script type="text/javascript" src="../../dynsections.js"></script>
    <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
    <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
    <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
    <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-custom.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../user_colors.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
    <script type="text/javascript" src="../../script-helper.js"></script>
    <script type="text/javascript" src="../../script-resize.js"></script>
    <script type="text/javascript" src="../../script-num-lines-code.js"></script>
    <script type="text/javascript" src="../../script-config-theme.js"></script>
    <script type="text/javascript" src="../../script-edit-config-theme.js"></script>
    <script type="text/javascript" src="../../script-alternative-theme.js"></script>
    <script type="text/javascript">
      // On demande l'activation de la personnalisation de la page.
      var no_custom_theme = false;
      DoxygenAwesomeDarkModeToggle.title = "Thème clair/sombre";
      DoxygenAwesomeDarkModeToggle.init();
      DoxygenAwesomeFragmentCopyButton.title = "Copier le code dans le presse-papier";
      DoxygenAwesomeFragmentCopyButton.init();
      DoxygenAwesomeParagraphLink.init();
      DoxygenAwesomeInteractiveToc.init();
      DoxygenAwesomeTabs.init()
      waitElemForResizeSideNav();
      setOldSize();
      //waitItemExpandCurrent();
    </script>
  </head>
  <body>
    <!--BEGIN CORNER_GITHUB-->
    <!-- https://tholman.com/github-corners/ -->
    <a href="https://github.com/arcaneframework/framework" class="github-corner" aria-label="Voir les sources sur GitHub">
      <svg width="70" height="70" viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor" class="octo-body"></path>
      </svg>
    </a>
    <!--END CORNER_GITHUB-->
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectlogo">
                  <a href="../../index.html" title="Aller à la page principale">
                    <img alt="Logo" src="../../arcane_framework_small.webp" />
                  </a>
                </td>
              </tr>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">Arcane
                    <span id="projectnumber">&#160;v4.1.0.0</span>
                  </div>
                  <div id="projectbrief">Documentation utilisateur</div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Généré par Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Recherche',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d6a/classArcane_1_1IMeshUtilities.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Chargement...</div>
<div class="SRStatus" id="Searching">Recherche...</div>
<div class="SRStatus" id="NoMatches">Aucune correspondance</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="../../db/d18/classArcane_1_1IMeshUtilities-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle"><div class="title">Référence de la classe Arcane::IMeshUtilities<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Interface d'une classe proposant des fonctions utilitaires sur maillage.  
 <a href="#details">Plus de détails...</a></p>

<p><code>#include &lt;<a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html">arcane/core/IMeshUtilities.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:a13483a3c2cc2a48c12903b9228940982" id="r_a13483a3c2cc2a48c12903b9228940982"><td class="memItemLeft" align="right" valign="top"><a id="a13483a3c2cc2a48c12903b9228940982" name="a13483a3c2cc2a48c12903b9228940982"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~IMeshUtilities</b> ()=default</td></tr>
<tr class="memdesc:a13483a3c2cc2a48c12903b9228940982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Libère les ressources. <br /></td></tr>
<tr class="separator:a13483a3c2cc2a48c12903b9228940982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cba21cbf201eb31a73be657dba6869" id="r_a94cba21cbf201eb31a73be657dba6869"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94cba21cbf201eb31a73be657dba6869">localIdsFromConnectivity</a> (<a class="el" href="../../d0/d32/namespaceArcane.html#aaa6951864e32e84c29b3cffca3d4b3f7">eItemKind</a> item_kind, <a class="el" href="../../d0/d32/namespaceArcane.html#ae33ca1247527a686930303a38614be87">IntegerConstArrayView</a> items_nb_node, <a class="el" href="../../d0/d32/namespaceArcane.html#a81737295dd6710426c0c568b41945c9b">Int64ConstArrayView</a> items_connectivity, <a class="el" href="../../d0/d32/namespaceArcane.html#aa251ec0b5630d54c00367faa205ce3e4">Int32ArrayView</a> local_ids, bool allow_null=false)=0</td></tr>
<tr class="memdesc:a94cba21cbf201eb31a73be657dba6869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recherche les identifiants locaux des entités à partir de leur connectivité.  <br /></td></tr>
<tr class="separator:a94cba21cbf201eb31a73be657dba6869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9797f5aec70b64815ff15c7165ed8407" id="r_a9797f5aec70b64815ff15c7165ed8407"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9797f5aec70b64815ff15c7165ed8407">getFacesLocalIdFromConnectivity</a> (<a class="el" href="../../d9/d2e/classArcane_1_1ConstArrayView.html">ConstArrayView</a>&lt; <a class="el" href="../../df/d8d/classArcane_1_1ItemTypeId.html">ItemTypeId</a> &gt; items_type, <a class="el" href="../../d9/d2e/classArcane_1_1ConstArrayView.html">ConstArrayView</a>&lt; <a class="el" href="../../d0/d32/namespaceArcane.html#a3fde8a7fe967e4fbe1c317b557db2561">Int64</a> &gt; items_connectivity, <a class="el" href="../../d2/d30/classArcane_1_1ArrayView.html">ArrayView</a>&lt; <a class="el" href="../../d0/d32/namespaceArcane.html#afb2dd299da58836c46f264f120bfefee">Int32</a> &gt; local_ids, bool allow_null=false)=0</td></tr>
<tr class="memdesc:a9797f5aec70b64815ff15c7165ed8407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recherche les identifiants locaux des faces à partir de leur connectivité.  <br /></td></tr>
<tr class="separator:a9797f5aec70b64815ff15c7165ed8407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3485a1b9b1c79bae701e8c55019fd274" id="r_a3485a1b9b1c79bae701e8c55019fd274"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3485a1b9b1c79bae701e8c55019fd274">computeNormal</a> (const <a class="el" href="../../de/db5/group__Mesh.html#ga715f63c87800d630ab5c58d9328c2bf2">FaceGroup</a> &amp;face_group, const <a class="el" href="../../d3/d00/group__Variable.html#ga954d8a49006416ac3fee399cfa47e022">VariableNodeReal3</a> &amp;nodes_coord)=0</td></tr>
<tr class="memdesc:a3485a1b9b1c79bae701e8c55019fd274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule la normale d'un groupe de face.  <br /></td></tr>
<tr class="separator:a3485a1b9b1c79bae701e8c55019fd274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06cbdcbcaec9025741020e13e6858d4" id="r_ad06cbdcbcaec9025741020e13e6858d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad06cbdcbcaec9025741020e13e6858d4">computeDirection</a> (const <a class="el" href="../../de/db5/group__Mesh.html#gabce375c2d244a5dddce4012e86327bea">NodeGroup</a> &amp;node_group, const <a class="el" href="../../d3/d00/group__Variable.html#ga954d8a49006416ac3fee399cfa47e022">VariableNodeReal3</a> &amp;nodes_coord, <a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a> *n1, <a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a> *n2)=0</td></tr>
<tr class="memdesc:ad06cbdcbcaec9025741020e13e6858d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule le vecteur directeur d'une ligne.  <br /></td></tr>
<tr class="separator:ad06cbdcbcaec9025741020e13e6858d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fec5acc52967274d7155dad96e3476" id="r_a46fec5acc52967274d7155dad96e3476"><td class="memItemLeft" align="right" valign="top"><a id="a46fec5acc52967274d7155dad96e3476" name="a46fec5acc52967274d7155dad96e3476"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>computeAdjency</b> (<a class="el" href="../../df/dbe/classArcane_1_1ItemPairGroup.html">ItemPairGroup</a> adjacency_array, <a class="el" href="../../d0/d32/namespaceArcane.html#aaa6951864e32e84c29b3cffca3d4b3f7">eItemKind</a> link_kind, <a class="el" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> nb_layer)=0</td></tr>
<tr class="memdesc:a46fec5acc52967274d7155dad96e3476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul des adjacences, rangées dans <em class="arg">adjacency_array</em>. <br /></td></tr>
<tr class="separator:a46fec5acc52967274d7155dad96e3476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a151f3573e48febb1c1696a2fd8c9b8" id="r_a6a151f3573e48febb1c1696a2fd8c9b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a151f3573e48febb1c1696a2fd8c9b8">computeAdjacency</a> (const <a class="el" href="../../df/dbe/classArcane_1_1ItemPairGroup.html">ItemPairGroup</a> &amp;adjacency_array, <a class="el" href="../../d0/d32/namespaceArcane.html#aaa6951864e32e84c29b3cffca3d4b3f7">eItemKind</a> link_kind, <a class="el" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> nb_layer)</td></tr>
<tr class="memdesc:a6a151f3573e48febb1c1696a2fd8c9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul des adjacences, rangées dans <em class="arg">adjacency_array</em>.  <br /></td></tr>
<tr class="separator:a6a151f3573e48febb1c1696a2fd8c9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0266268ca4c31dfca2884d8ed75f3742" id="r_a0266268ca4c31dfca2884d8ed75f3742"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0266268ca4c31dfca2884d8ed75f3742">changeOwnersFromCells</a> ()=0</td></tr>
<tr class="memdesc:a0266268ca4c31dfca2884d8ed75f3742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positionne les nouveaux propriétaires des noeuds, arêtes et faces à partir des mailles.  <br /></td></tr>
<tr class="separator:a0266268ca4c31dfca2884d8ed75f3742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9bb748c7b30f05fec6cf3bd3e3f85d" id="r_a7a9bb748c7b30f05fec6cf3bd3e3f85d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a9bb748c7b30f05fec6cf3bd3e3f85d">computeAndSetOwnersForNodes</a> ()=0</td></tr>
<tr class="memdesc:a7a9bb748c7b30f05fec6cf3bd3e3f85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Détermine les propriétaires des noeuds.  <br /></td></tr>
<tr class="separator:a7a9bb748c7b30f05fec6cf3bd3e3f85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a27fb95adeb54abe5d3313a9b053bdb" id="r_a7a27fb95adeb54abe5d3313a9b053bdb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a27fb95adeb54abe5d3313a9b053bdb">computeAndSetOwnersForEdges</a> ()=0</td></tr>
<tr class="memdesc:a7a27fb95adeb54abe5d3313a9b053bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Détermine les propriétaires des arêtes.  <br /></td></tr>
<tr class="separator:a7a27fb95adeb54abe5d3313a9b053bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6349497829f89ffad110bbcdb45b2326" id="r_a6349497829f89ffad110bbcdb45b2326"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6349497829f89ffad110bbcdb45b2326">computeAndSetOwnersForFaces</a> ()=0</td></tr>
<tr class="memdesc:a6349497829f89ffad110bbcdb45b2326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Détermine les propriétaires des faces.  <br /></td></tr>
<tr class="separator:a6349497829f89ffad110bbcdb45b2326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad598420d46767e5c42ae0419b28b54b5" id="r_ad598420d46767e5c42ae0419b28b54b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad598420d46767e5c42ae0419b28b54b5">writeToFile</a> (const <a class="el" href="../../db/dc4/classArcane_1_1String.html">String</a> &amp;file_name, const <a class="el" href="../../db/dc4/classArcane_1_1String.html">String</a> &amp;service_name)=0</td></tr>
<tr class="memdesc:ad598420d46767e5c42ae0419b28b54b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ecrit le maillage dans un fichier.  <br /></td></tr>
<tr class="separator:ad598420d46767e5c42ae0419b28b54b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac921b802514527397efa68202112e73e" id="r_ac921b802514527397efa68202112e73e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac921b802514527397efa68202112e73e">partitionAndExchangeMeshWithReplication</a> (<a class="el" href="../../d8/d7d/classArcane_1_1IMeshPartitionerBase.html">IMeshPartitionerBase</a> *partitioner, bool initial_partition)=0</td></tr>
<tr class="memdesc:ac921b802514527397efa68202112e73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartitionne et échange le maillage en gérant la réplication.  <br /></td></tr>
<tr class="separator:ac921b802514527397efa68202112e73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d028831945d87c9f8ff405bdd40ab76" id="r_a2d028831945d87c9f8ff405bdd40ab76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d028831945d87c9f8ff405bdd40ab76">mergeNodes</a> (<a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a> nodes_local_id, <a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a> nodes_to_merge_local_id)</td></tr>
<tr class="memdesc:a2d028831945d87c9f8ff405bdd40ab76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fusionne des nœuds.  <br /></td></tr>
<tr class="separator:a2d028831945d87c9f8ff405bdd40ab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2bba7fabf5cf74f899fa82c9897650" id="r_a5a2bba7fabf5cf74f899fa82c9897650"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a2bba7fabf5cf74f899fa82c9897650">mergeNodes</a> (<a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a> nodes_local_id, <a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a> nodes_to_merge_local_id, bool allow_non_corresponding_face)=0</td></tr>
<tr class="memdesc:a5a2bba7fabf5cf74f899fa82c9897650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fusionne des nœuds.  <br /></td></tr>
<tr class="separator:a5a2bba7fabf5cf74f899fa82c9897650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad719d78a193d986a0cfd94d73cb368f2" id="r_ad719d78a193d986a0cfd94d73cb368f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad719d78a193d986a0cfd94d73cb368f2">recomputeItemsUniqueIdFromNodesUniqueId</a> ()=0</td></tr>
<tr class="memdesc:ad719d78a193d986a0cfd94d73cb368f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalcule les uniqueId() des arêtes, faces et mailles en fonction des uniqueId() des noeuds.  <br /></td></tr>
<tr class="separator:ad719d78a193d986a0cfd94d73cb368f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Interface d'une classe proposant des fonctions utilitaires sur maillage. </p>

<p class="definition">Définition à la ligne <a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html#l00034">34</a> du fichier <a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html">IMeshUtilities.h</a>.</p>
</div><h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="a0266268ca4c31dfca2884d8ed75f3742" name="a0266268ca4c31dfca2884d8ed75f3742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0266268ca4c31dfca2884d8ed75f3742">&#9670;&#160;</a></span>changeOwnersFromCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::changeOwnersFromCells </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positionne les nouveaux propriétaires des noeuds, arêtes et faces à partir des mailles. </p>
<p>En considérant que les nouveaux propriétaires des mailles sont connus (et synchronisés), détermine les nouveaux propriétaires des autres entités et les synchronise.</p>
<p>Cette méthode est collective.</p>
<dl class="section note"><dt>Note</dt><dd>Cette méthode nécessite que les informations de synchronisations soient valides. Si on souhaite déterminer les propriétaires des entités sans information préalable, il faut utiliser <a class="el" href="#a7a9bb748c7b30f05fec6cf3bd3e3f85d" title="Détermine les propriétaires des noeuds.">computeAndSetOwnersForNodes()</a> ou <a class="el" href="#a6349497829f89ffad110bbcdb45b2326" title="Détermine les propriétaires des faces.">computeAndSetOwnersForFaces()</a>. </dd></dl>

<p class="reference">Références <a class="el" href="#a0266268ca4c31dfca2884d8ed75f3742">changeOwnersFromCells()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a0266268ca4c31dfca2884d8ed75f3742">changeOwnersFromCells()</a>.</p>

</div>
</div>
<a id="a6a151f3573e48febb1c1696a2fd8c9b8" name="a6a151f3573e48febb1c1696a2fd8c9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a151f3573e48febb1c1696a2fd8c9b8">&#9670;&#160;</a></span>computeAdjacency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Arcane::IMeshUtilities::computeAdjacency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dbe/classArcane_1_1ItemPairGroup.html">ItemPairGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#aaa6951864e32e84c29b3cffca3d4b3f7">eItemKind</a></td>          <td class="paramname"><span class="paramname"><em>link_kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a></td>          <td class="paramname"><span class="paramname"><em>nb_layer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcul des adjacences, rangées dans <em class="arg">adjacency_array</em>. </p>

<p class="definition">Définition à la ligne <a class="el" href="../../d2/dec/InterfaceImpl_8cc_source.html#l00329">329</a> du fichier <a class="el" href="../../d2/dec/InterfaceImpl_8cc_source.html">InterfaceImpl.cc</a>.</p>

<p class="reference">Références <a class="el" href="#a46fec5acc52967274d7155dad96e3476">computeAdjency()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a46fec5acc52967274d7155dad96e3476">computeAdjency()</a>.</p>

</div>
</div>
<a id="a7a27fb95adeb54abe5d3313a9b053bdb" name="a7a27fb95adeb54abe5d3313a9b053bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a27fb95adeb54abe5d3313a9b053bdb">&#9670;&#160;</a></span>computeAndSetOwnersForEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::computeAndSetOwnersForEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Détermine les propriétaires des arêtes. </p>
<p>La détermination se fait en fonction des propriétaires des mailles. Il ne doit pas y avoir de couches de mailles fantômes.</p>
<p>Cette opération est collective. </p>

<p class="reference">Références <a class="el" href="#a7a27fb95adeb54abe5d3313a9b053bdb">computeAndSetOwnersForEdges()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a7a27fb95adeb54abe5d3313a9b053bdb">computeAndSetOwnersForEdges()</a>.</p>

</div>
</div>
<a id="a6349497829f89ffad110bbcdb45b2326" name="a6349497829f89ffad110bbcdb45b2326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6349497829f89ffad110bbcdb45b2326">&#9670;&#160;</a></span>computeAndSetOwnersForFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::computeAndSetOwnersForFaces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Détermine les propriétaires des faces. </p>
<p>La détermination se fait en fonction des propriétaires des mailles. Il ne doit pas y avoir de couches de mailles fantômes.</p>
<p>Cette opération est collective. </p>

<p class="reference">Références <a class="el" href="#a6349497829f89ffad110bbcdb45b2326">computeAndSetOwnersForFaces()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a6349497829f89ffad110bbcdb45b2326">computeAndSetOwnersForFaces()</a>.</p>

</div>
</div>
<a id="a7a9bb748c7b30f05fec6cf3bd3e3f85d" name="a7a9bb748c7b30f05fec6cf3bd3e3f85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9bb748c7b30f05fec6cf3bd3e3f85d">&#9670;&#160;</a></span>computeAndSetOwnersForNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::computeAndSetOwnersForNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Détermine les propriétaires des noeuds. </p>
<p>La détermination se fait en fonction des propriétaires des mailles. Il ne doit pas y avoir de couches de mailles fantômes.</p>
<p>Cette opération est collective. </p>

<p class="reference">Références <a class="el" href="#a7a9bb748c7b30f05fec6cf3bd3e3f85d">computeAndSetOwnersForNodes()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a7a9bb748c7b30f05fec6cf3bd3e3f85d">computeAndSetOwnersForNodes()</a>.</p>

</div>
</div>
<a id="ad06cbdcbcaec9025741020e13e6858d4" name="ad06cbdcbcaec9025741020e13e6858d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06cbdcbcaec9025741020e13e6858d4">&#9670;&#160;</a></span>computeDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a> Arcane::IMeshUtilities::computeDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db5/group__Mesh.html#gabce375c2d244a5dddce4012e86327bea">NodeGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node_group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d00/group__Variable.html#ga954d8a49006416ac3fee399cfa47e022">VariableNodeReal3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes_coord</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a> *</td>          <td class="paramname"><span class="paramname"><em>n1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a> *</td>          <td class="paramname"><span class="paramname"><em>n2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcule le vecteur directeur d'une ligne. </p>
<p>Cette méthode calcule le vecteur directeur d'un groupe de noeuds en considérant qu'il forme une ligne. Pour le calcul, l'algorithme essaie de déterminer les noeuds aux extrémités de cette ligne, et calcule un vecteur à partir de ces noeuds. Le sens du vecteur est indéfini.</p>
<p>Si le groupe ne forme pas une ligne, le résultat est indéfini.</p>
<p>Cette méthode est collective. L'algorithme utilisé garantit les mêmes résultats en séquentiel et en parallèle.</p>
<p>Si <em class="arg">n1</em> et <em class="arg">n2</em> ne sont pas nuls, ils contiendront en sortie les coordonnées extrèmes à partir desquelles la direction est calculée.</p>
<p>La variable <em class="arg">nodes_coord</em> est utilisée comme coordonnées pour les noeuds. En général, il s'agit de <a class="el" href="../../d0/d9f/classArcane_1_1IMesh.html#a09c0ba5f9c8e90618cc48d7f79e1c640" title="Coordonnées des noeuds.">IMesh::nodesCoordinates()</a>. </p>

<p class="reference">Références <a class="el" href="#ad06cbdcbcaec9025741020e13e6858d4">computeDirection()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#ad06cbdcbcaec9025741020e13e6858d4">computeDirection()</a>.</p>

</div>
</div>
<a id="a3485a1b9b1c79bae701e8c55019fd274" name="a3485a1b9b1c79bae701e8c55019fd274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3485a1b9b1c79bae701e8c55019fd274">&#9670;&#160;</a></span>computeNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d1/da6/classArcane_1_1Real3.html">Real3</a> Arcane::IMeshUtilities::computeNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db5/group__Mesh.html#ga715f63c87800d630ab5c58d9328c2bf2">FaceGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>face_group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d00/group__Variable.html#ga954d8a49006416ac3fee399cfa47e022">VariableNodeReal3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes_coord</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcule la normale d'un groupe de face. </p>
<p>Cette méthode calcule la normale à un groupe de face en considérant que cette surface est un plan. Pour le calcul, l'algorithme essaie de déterminer les noeuds aux extrémités de cette surface, et calcule une normale à partir de ces noeuds. L'orientation de la normale (rentrante ou sortante) est indéfinie.</p>
<p>Si la surface n'est pas plane, le résultat est indéfini.</p>
<p>L'algorithme actuel ne fonctionne pas toujours sur une surface composée uniquement de triangles.</p>
<p>Cette méthode est collective. L'algorithme utilisé garantit les mêmes résultats en séquentiel et en parallèle.</p>
<p>La variable <em class="arg">nodes_coord</em> est utilisée comme coordonnées pour les noeuds. En général, il s'agit de <a class="el" href="../../d0/d9f/classArcane_1_1IMesh.html#a09c0ba5f9c8e90618cc48d7f79e1c640" title="Coordonnées des noeuds.">IMesh::nodesCoordinates()</a>. </p>

<p class="reference">Références <a class="el" href="#a3485a1b9b1c79bae701e8c55019fd274">computeNormal()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a3485a1b9b1c79bae701e8c55019fd274">computeNormal()</a>.</p>

</div>
</div>
<a id="a9797f5aec70b64815ff15c7165ed8407" name="a9797f5aec70b64815ff15c7165ed8407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9797f5aec70b64815ff15c7165ed8407">&#9670;&#160;</a></span>getFacesLocalIdFromConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::getFacesLocalIdFromConnectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d2e/classArcane_1_1ConstArrayView.html">ConstArrayView</a>&lt; <a class="el" href="../../df/d8d/classArcane_1_1ItemTypeId.html">ItemTypeId</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>items_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d2e/classArcane_1_1ConstArrayView.html">ConstArrayView</a>&lt; <a class="el" href="../../d0/d32/namespaceArcane.html#a3fde8a7fe967e4fbe1c317b557db2561">Int64</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>items_connectivity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d30/classArcane_1_1ArrayView.html">ArrayView</a>&lt; <a class="el" href="../../d0/d32/namespaceArcane.html#afb2dd299da58836c46f264f120bfefee">Int32</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>local_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_null</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recherche les identifiants locaux des faces à partir de leur connectivité. </p>
<p>Prend en entrée une liste d'entités décrite par les identifiants uniques (<a class="el" href="../../df/d5f/classArcane_1_1Item.html#a8e5cf3572ae8a043fae3e32fe400551b" title="Identifiant unique sur tous les domaines.">Item::uniqueId()</a>) de leurs noeuds et recherche les identifiants locaux (<a class="el" href="../../df/d5f/classArcane_1_1Item.html#a337f519e8727634e55ea621f4734ec04" title="Identifiant local de l&#39;entité dans le sous-domaine du processeur.">Item::localId()</a>) de ces entités.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">items_type</td><td>tableau des <a class="el" href="../../df/d8d/classArcane_1_1ItemTypeId.html" title="Type d&#39;une entité (Item).">ItemTypeId</a> des entités </td></tr>
    <tr><td class="paramname">items_connectivity</td><td>tableau contenant les indices uniques des noeuds des entités. </td></tr>
    <tr><td class="paramname">local_ids</td><td>en retour, contient les identifiants locaux des entités. Le nombre d'éléments de <em class="arg">local_ids</em> doit être égal à celui de <em class="arg">items_nb_node</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Le tableau <em class="arg">items_connectivity</em> contient les identifiants des noeuds des faces, rangés consécutivement. Par exemple, si <code>items_type</code>[0]==IT_Triangle3 et <code>items_type</code>[1]==IT_Quad4, alors <em class="arg">items_connectivity</em>[0..2] contiendra les noeuds de l'entité 0, et items_connectivity[3..6] ceux de l'entité 1.</p>
<p>Si <em class="arg">allow_null</em> est faux, une erreur fatale est générée si une entité n'est pas trouvée, sinon NULL_ITEM_LOCAL_ID est retourné pour l'entité correspondante. </p>

<p class="reference">Références <a class="el" href="#a9797f5aec70b64815ff15c7165ed8407">getFacesLocalIdFromConnectivity()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a9797f5aec70b64815ff15c7165ed8407">getFacesLocalIdFromConnectivity()</a>.</p>

</div>
</div>
<a id="a94cba21cbf201eb31a73be657dba6869" name="a94cba21cbf201eb31a73be657dba6869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cba21cbf201eb31a73be657dba6869">&#9670;&#160;</a></span>localIdsFromConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::localIdsFromConnectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#aaa6951864e32e84c29b3cffca3d4b3f7">eItemKind</a></td>          <td class="paramname"><span class="paramname"><em>item_kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#ae33ca1247527a686930303a38614be87">IntegerConstArrayView</a></td>          <td class="paramname"><span class="paramname"><em>items_nb_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#a81737295dd6710426c0c568b41945c9b">Int64ConstArrayView</a></td>          <td class="paramname"><span class="paramname"><em>items_connectivity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#aa251ec0b5630d54c00367faa205ce3e4">Int32ArrayView</a></td>          <td class="paramname"><span class="paramname"><em>local_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_null</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recherche les identifiants locaux des entités à partir de leur connectivité. </p>
<p>Cette méthode n'est implémentée que pour les faces d'ordre 1.</p>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000040">Obsolète</a></b></dt><dd>Utiliser <a class="el" href="#a9797f5aec70b64815ff15c7165ed8407" title="Recherche les identifiants locaux des faces à partir de leur connectivité.">getFacesLocalIdFromConnectivity()</a> à la place. </dd></dl>

<p class="reference">Références <a class="el" href="#a94cba21cbf201eb31a73be657dba6869">localIdsFromConnectivity()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#a94cba21cbf201eb31a73be657dba6869">localIdsFromConnectivity()</a>.</p>

</div>
</div>
<a id="a2d028831945d87c9f8ff405bdd40ab76" name="a2d028831945d87c9f8ff405bdd40ab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d028831945d87c9f8ff405bdd40ab76">&#9670;&#160;</a></span>mergeNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::mergeNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a></td>          <td class="paramname"><span class="paramname"><em>nodes_local_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a></td>          <td class="paramname"><span class="paramname"><em>nodes_to_merge_local_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fusionne des nœuds. </p>

<p class="definition">Définition à la ligne <a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html#l00237">237</a> du fichier <a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html">IMeshUtilities.h</a>.</p>

<p class="reference">Références <a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html#l00237">mergeNodes()</a>.</p>

<p class="reference">Référencé par <a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html#l00237">mergeNodes()</a>.</p>

</div>
</div>
<a id="a5a2bba7fabf5cf74f899fa82c9897650" name="a5a2bba7fabf5cf74f899fa82c9897650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2bba7fabf5cf74f899fa82c9897650">&#9670;&#160;</a></span>mergeNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::mergeNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a></td>          <td class="paramname"><span class="paramname"><em>nodes_local_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d32/namespaceArcane.html#a53258f59fa80989bb5c9154376b5000e">Int32ConstArrayView</a></td>          <td class="paramname"><span class="paramname"><em>nodes_to_merge_local_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_non_corresponding_face</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fusionne des nœuds. </p>
<p>Fusionne deux à deux les nœuds de <em class="arg">nodes_to_merge_local_id</em> avec ceux de <em class="arg">nodes_local_id</em>. Chaque nœud <em class="arg">nodes_to_merge_local_id</em>[i] est fusionné avec <em class="arg">nodes_local_id</em>[i].</p>
<p>Les nœuds <em class="arg">nodes_to_merge_local_id</em> sont détruits après fusion. Les entités reposant entièrement sur ces nœuds fusionnés sont aussi détruites.</p>
<p>Il est interdit de fusionner deux nœuds d'une même maille ou d'une même face (après fusion, une face ou une maille ne peut pas avoir deux fois le même nœud).</p>
<p>Une fois la fusion effectuée, les faces contenant les nœuds fusionnés (<em class="arg">nodes_to_merge_local_id</em>) sont détruites. Si <em class="arg">allow_non_corresponding_face</em> est faux, alors pour chaque face détruite doit correspondre une face existante avec les nœuds fusionnés (<em class="arg">nodes_local_id</em>). </p>

</div>
</div>
<a id="ac921b802514527397efa68202112e73e" name="ac921b802514527397efa68202112e73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac921b802514527397efa68202112e73e">&#9670;&#160;</a></span>partitionAndExchangeMeshWithReplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::partitionAndExchangeMeshWithReplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d7d/classArcane_1_1IMeshPartitionerBase.html">IMeshPartitionerBase</a> *</td>          <td class="paramname"><span class="paramname"><em>partitioner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>initial_partition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartitionne et échange le maillage en gérant la réplication. </p>
<p>Cette méthode effectue un repartitionnement du maillage via l'appel à <a class="el" href="../../dc/dd8/classArcane_1_1IMeshPartitioner.html#ac35bdf105ca7509f0477f54c5527e44d">IMeshPartitioner::partitionMesh(bool)</a> et procède à l'échange des entités via <a class="el" href="../../d7/d89/classArcane_1_1IPrimaryMesh.html#a5ebed7b92c2b56b2eb64fa19090d6d06" title="Change les sous-domaines propriétaires des entités.">IPrimaryMesh::exchangeItems()</a>.</p>
<p>Elle mais gère aussi la réplication en s'assurant que tous les réplica ont le même maillage. Le principe est le suivant:</p><ul>
<li>seul le réplica maître effectue le repartitionnement en appelant IMeshPartitioner::partitionMesh() avec <em class="arg">partitioner</em> comme partitionneur</li>
<li>les valeurs des <a class="el" href="../../dd/d0a/classArcane_1_1IItemFamily.html#ae0c3a21b4dd921d789093afe4915877e" title="Variable contenant le numéro du nouveau sous-domaine propriétaire de l&#39;entité.">IItemFamily::itemsNewOwner()</a> sont ensuite synchronisées avec les autres réplicas.</li>
<li>les échanges d'entités sont effectués via <a class="el" href="../../d7/d89/classArcane_1_1IPrimaryMesh.html#a5ebed7b92c2b56b2eb64fa19090d6d06" title="Change les sous-domaines propriétaires des entités.">IPrimaryMesh::exchangeItems()</a>.</li>
</ul>
<p>Cette méthode est collective sur l'ensemble des réplicas.</p>
<dl class="section pre"><dt>Précondition</dt><dd>Tous les réplicas doivent avoir le même maillage, c'est à dire que toutes les familles d'entités doivent être identiques à l'exception des familles de particules qui ne sont pas concernées. </dd>
<dd>
Le maillage doit être une instance de <a class="el" href="../../d7/d89/classArcane_1_1IPrimaryMesh.html">IPrimaryMesh</a>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Tous les réplicas ont le même maillage à l'exception des familles de particules.</dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitioner</td><td>Instance du partitionneur à utiliser </td></tr>
    <tr><td class="paramname">initial_partition</td><td>Indique s'il s'agit du partitionnement initial. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Références <a class="el" href="#ac921b802514527397efa68202112e73e">partitionAndExchangeMeshWithReplication()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#ac921b802514527397efa68202112e73e">partitionAndExchangeMeshWithReplication()</a>.</p>

</div>
</div>
<a id="ad719d78a193d986a0cfd94d73cb368f2" name="ad719d78a193d986a0cfd94d73cb368f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad719d78a193d986a0cfd94d73cb368f2">&#9670;&#160;</a></span>recomputeItemsUniqueIdFromNodesUniqueId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Arcane::IMeshUtilities::recomputeItemsUniqueIdFromNodesUniqueId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recalcule les uniqueId() des arêtes, faces et mailles en fonction des uniqueId() des noeuds. </p>
<dl class="section warning"><dt>Avertissement</dt><dd>Cette méthode est expérimentale et ne doit être utilisée que dans <a class="el" href="../../d0/d32/namespaceArcane.html" title="-*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-">Arcane</a>. Elle suppose que les uniqueId() des entités sont construit à partir de generateHashUniqueId(). </dd></dl>

</div>
</div>
<a id="ad598420d46767e5c42ae0419b28b54b5" name="ad598420d46767e5c42ae0419b28b54b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad598420d46767e5c42ae0419b28b54b5">&#9670;&#160;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Arcane::IMeshUtilities::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dc4/classArcane_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/dc4/classArcane_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>service_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ecrit le maillage dans un fichier. </p>
<p>Ecrit le maillage dans le fichier <em class="arg">file_name</em> en utilisant le service implémentant l'interface '<a class="el" href="../../dc/d13/classArcane_1_1IMeshWriter.html" title="Interface d&#39;un service d&#39;écriture d&#39;un maillage.">IMeshWriter</a>' et de nom <em class="arg">service_name</em>.</p>
<dl class="retval"><dt>Valeurs retournées</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>si le service spécifié n'est pas disponible. </td></tr>
    <tr><td class="paramname">false</td><td>si tout est ok. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Références <a class="el" href="#ad598420d46767e5c42ae0419b28b54b5">writeToFile()</a>.</p>

<p class="reference">Référencé par <a class="el" href="#ad598420d46767e5c42ae0419b28b54b5">writeToFile()</a>.</p>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir des fichiers suivants :<ul>
<li><a class="el" href="../../d1/d67/IMeshUtilities_8h_source.html">IMeshUtilities.h</a></li>
<li><a class="el" href="../../d2/dec/InterfaceImpl_8cc_source.html">InterfaceImpl.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
  <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
      <li class="navelem"><a class="el" href="../../d0/d32/namespaceArcane.html">Arcane</a></li><li class="navelem"><a class="el" href="../../dd/d6a/classArcane_1_1IMeshUtilities.html">IMeshUtilities</a></li>
      <li class="footer">Généré le Lundi 20 Octobre 2025 03:12:36 pour Arcane par <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
    </ul>
  </div>
  <script type="text/javascript" src="../../script-apply-config-theme.js"></script>
  <script type="text/javascript">
    // On met l'appel à cette fonction dans le footer dans le cas où
    // une page ne veut pas de personnalisation (changement de la 
    // variable globale "no_custom_theme").
    applyConfigWithCookies();
  </script>
</body>
</html>
