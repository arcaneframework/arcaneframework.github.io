<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.13.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="../../logo_arcane.svg" type="image/svg+xml">
    <title>Arcane: Les fenêtres mémoires en mémoire partagée en multi-processus</title>
    <link href="../../tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="../../jquery.js"></script>
    <script type="text/javascript" src="../../dynsections.js"></script>
    <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
    <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
    <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
    <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-custom.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../user_colors.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
    <script type="text/javascript" src="../../script-helper.js"></script>
    <script type="text/javascript" src="../../script-resize.js"></script>
    <script type="text/javascript" src="../../script-num-lines-code.js"></script>
    <script type="text/javascript" src="../../script-config-theme.js"></script>
    <script type="text/javascript" src="../../script-edit-config-theme.js"></script>
    <script type="text/javascript" src="../../script-alternative-theme.js"></script>
    <script type="text/javascript">
      // On demande l'activation de la personnalisation de la page.
      var no_custom_theme = false;
      DoxygenAwesomeDarkModeToggle.title = "Thème clair/sombre";
      DoxygenAwesomeDarkModeToggle.init();
      DoxygenAwesomeFragmentCopyButton.title = "Copier le code dans le presse-papier";
      DoxygenAwesomeFragmentCopyButton.init();
      DoxygenAwesomeParagraphLink.init();
      DoxygenAwesomeInteractiveToc.init();
      DoxygenAwesomeTabs.init()
      waitElemForResizeSideNav();
      setOldSize();
      //waitItemExpandCurrent();
    </script>
  </head>
  <body>
    <!--BEGIN CORNER_GITHUB-->
    <!-- https://tholman.com/github-corners/ -->
    <a href="https://github.com/arcaneframework/framework" class="github-corner" aria-label="Voir les sources sur GitHub">
      <svg width="70" height="70" viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor" class="octo-body"></path>
      </svg>
    </a>
    <!--END CORNER_GITHUB-->
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectlogo">
                  <a href="../../index.html" title="Aller à la page principale">
                    <img alt="Logo" src="../../arcane_framework_small.webp" />
                  </a>
                </td>
              </tr>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">Arcane
                    <span id="projectnumber">&#160;v4.1.4.0</span>
                  </div>
                  <div id="projectbrief">Documentation utilisateur</div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Généré par Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Recherche',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/d68/arcanedoc_parallel_shmem.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Chargement...</div>
<div class="SRStatus" id="Searching">Recherche...</div>
<div class="SRStatus" id="NoMatches">Aucune correspondance</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Les fenêtres mémoires en mémoire partagée en multi-processus</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table des matières</h3>
<ul>
  <li class="level1">
    <a href="#arcanedoc_parallel_shmem_intro">Introduction</a>
  </li>
  <li class="level1">
    <a href="#arcanedoc_parallel_shmem_const">Implémentation avec taille constante</a>
    <ul>
      <li class="level2">
        <a href="#arcanedoc_parallel_shmem_const_usage">Utilisation</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#arcanedoc_parallel_shmem_var">Implémentation avec taille variable</a>
    <ul>
      <li class="level2">
        <a href="#arcanedoc_parallel_shmem_var_usage">Utilisation</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#arcanedoc_parallel_shmem_shmem">Mémoire partagée entre processus</a>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_doc_2doc__user_2chap__parallel_25__shmem"></a></p>
<h1><a class="anchor" id="arcanedoc_parallel_shmem_intro"></a>
Introduction</h1>
<p>Cette page va décrire comment utiliser la mémoire partagée entre les processus d'un même noeud de calcul à l'aide de fenêtres mémoires.</p>
<p>Une fenêtre mémoire est un espace mémoire alloué dans une partie de la mémoire accessible par tous les processus. Cette fenêtre sera découpée en plusieurs segments, un par processus.</p>
<p>Deux implémentations différentes sont disponibles : une avec une taille constante, définie lors de la construction de l'objet et une autre avec une taille pouvant évoluer.</p>
<h1><a class="anchor" id="arcanedoc_parallel_shmem_const"></a>
Implémentation avec taille constante</h1>
<p>Cette implémentation va permettre de créer une fenêtre mémoire ayant tous ses segments contigüs. Il est ainsi assez simple de redécouper les segments pendant l'utilisation (par exemple, pour équilibrer un calcul).</p>
<h2><a class="anchor" id="arcanedoc_parallel_shmem_const_usage"></a>
Utilisation</h2>
<p>Cette partie est gérée par la classe <a class="el" href="../../d7/db6/classArcane_1_1MachineMemoryWindow.html" title="Classe permettant de créer une fenêtre mémoire partagée entre les sous-domaines d&#39;un même noeud....">Arcane::MachineMemoryWindow</a>.</p>
<p>Cette classe peut utiliser trois implémentations de IMachineMemoryWindowBase, une par type de <a class="el" href="../../dc/d5a/classArcane_1_1IParallelMng.html" title="Interface du gestionnaire de parallélisme pour un sous-domaine.">Arcane::IParallelMng</a>. Il est donc possible d'utiliser cette classe de la même façon, que l'on ait un MpiParallelMng, un SequentialParallelMng, un SharedMemoryParallelMng ou un HybridParallelMng (<a class="el" href="../../d8/dd6/arcanedoc_execution_launcher.html#arcanedoc_execution_launcher_exchange">Choix du gestionnaire d'échange de message</a>).</p>
<p>La création d'un objet de ce type est collectif. Une instance de cette classe va créer une fenêtre mémoire composée de plusieurs segments (un par sous-domaine).</p>
<p>L'accès aux éléments des segments n'est pas collectif. L'accès concurrent à un élément est possible en utilisant des sémaphores, des mutex ou des std::atomic. Pour les std::atomic, il faut que les opérations soient <code>address-free</code> :</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_lock_free = std::atomic&lt;Real&gt;{}.is_lock_free();</div>
</div><!-- fragment --><p>Lors de la construction de cet objet, chaque sous-domaine va fournir une taille de segment. La taille de la fenêtre va être égale à la somme des tailles de segments.</p>
<div class="fragment"><div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> nb_elem = 14;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../dc/d5a/classArcane_1_1IParallelMng.html">IParallelMng</a>* pm = m_parallel_mng;</div>
<div class="line">    <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> my_rank = pm-&gt;<a class="code hl_function" href="../../dc/d5a/classArcane_1_1IParallelMng.html#a26fc7494a02a7370d3be787fcc742b04">commRank</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d7/db6/classArcane_1_1MachineMemoryWindow.html">MachineMemoryWindow&lt;Integer&gt;</a> window(pm, nb_elem);<span class="comment"></span></div>
</div><!-- fragment --><p>Pour accéder à son segment, il est possible d'utiliser la méthode <a class="el" href="../../d7/db6/classArcane_1_1MachineMemoryWindow.html#acc45d1a513a915648c4d202f4f7ce59b" title="Méthode permettant d&#39;obtenir une vue sur notre segment de fenêtre mémoire.">Arcane::MachineMemoryWindow::segmentView()</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <a class="code hl_class" href="../../d2/d5e/classArcane_1_1Span.html">Span</a> av_my_segment(window.segmentView());</div>
<div class="line"> </div>
<div class="line">      <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> iter = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a>&amp; elem : av_my_segment) {</div>
<div class="line">        elem = iter * (my_rank + 1);</div>
<div class="line">        iter++;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    window.barrier();<span class="comment"></span></div>
</div><!-- fragment --><p>Une fois le segment modifié, on peut faire une barrier pour s'assurer que tout le monde a écrit dans son segment avant de s'en servir.</p>
<p>Pour savoir quels sous-domaines se partagent une fenêtre sur le noeud, il est possible de récupérer un tableau de rang.</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="../../d9/d2e/classArcane_1_1ConstArrayView.html">ConstArrayView&lt;Int32&gt;</a> machine_ranks(window.machineRanks());</div>
<div class="line">    <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> machine_nb_proc = machine_ranks.size();<span class="comment"></span></div>
</div><!-- fragment --><p>La position des rangs dans ce tableau correspond à la position de leur segment dans la fenêtre.</p>
<p>Pour la lecture des segments des autres sous-domaines du noeud, on peut utiliser la méthode <a class="el" href="../../d7/db6/classArcane_1_1MachineMemoryWindow.html#aeccd84d5d38812ac5887a896876168ba" title="Méthode permettant d&#39;obtenir une vue constante sur notre segment de fenêtre mémoire.">Arcane::MachineMemoryWindow::segmentConstView()</a>.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (Int32 rank : machine_ranks) {</div>
<div class="line">      <a class="code hl_class" href="../../d2/d5e/classArcane_1_1Span.html">Span</a> av_segment(window.segmentConstView(rank));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; nb_elem; ++i) {</div>
<div class="line">        <span class="keywordflow">if</span> (av_segment[i] != i * (rank + 1)) {</div>
<div class="line">          <a class="code hl_define" href="../../d0/d1e/ArcaneGlobal_8h.html#a9d85d5fb84c5371348dd56600999e564">ARCANE_FATAL</a>(<span class="stringliteral">&quot;Bad element in memory window -- Expected : {0} -- Found : {1}&quot;</span>, (i * (rank + 1)), av_segment[i]);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }<span class="comment"></span></div>
</div><!-- fragment --><p>La taille de la fenêtre ne peut pas être modifiée. En revanche, l'implémentation dans Arcane permet de redimensionner les segments de manière collectif (à la condition que la nouvelle taille de la fenêtre soit inférieure ou égale à la taille d'origine).</p>
<dl class="section note"><dt>Note</dt><dd>Une implémentation avec des fenêtres mémoires ayant des segments non-contigües pourrait être plus performante mais rendrait cette fonctionnalité impossible.</dd></dl>
<div class="fragment"><div class="line">    window.barrier();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> nb_elem_div = nb_elem / 2;</div>
<div class="line"> </div>
<div class="line">    window.resizeSegment(nb_elem_div);<span class="comment"></span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarques</dt><dd>Les éléments de la fenêtre ne sont pas modifiés pendant le redimensionnement.</dd></dl>
<p>La fenêtre étant contigüe, l'accès à toute la fenêtre est possible pour tous les sous-domaines.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (my_rank == machine_ranks[0]) {</div>
<div class="line">      <a class="code hl_class" href="../../d2/d5e/classArcane_1_1Span.html">Span</a> av_window(window.windowView());</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> j = 0; j &lt; machine_nb_proc; ++j) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; nb_elem; ++i) {</div>
<div class="line">          av_window[i + (j * nb_elem)] = machine_ranks[j];</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    window.barrier();</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_class" href="../../d2/d5e/classArcane_1_1Span.html">Span</a> av_window(window.windowConstView());</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> j = 0; j &lt; machine_nb_proc; ++j) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; nb_elem; ++i) {</div>
<div class="line">          <span class="keywordflow">if</span> (av_window[i + (j * nb_elem)] != machine_ranks[j]) {</div>
<div class="line">            <a class="code hl_define" href="../../d0/d1e/ArcaneGlobal_8h.html#a9d85d5fb84c5371348dd56600999e564">ARCANE_FATAL</a>(<span class="stringliteral">&quot;Bad element in memory window -- Expected : {0} -- Found : {1}&quot;</span>, machine_ranks[j], av_window[i + (j * nb_elem)]);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    window.barrier();<span class="comment"></span></div>
</div><!-- fragment --><h1><a class="anchor" id="arcanedoc_parallel_shmem_var"></a>
Implémentation avec taille variable</h1>
<p>Cette implémentation est assez différente de la précédente. Ici, les segments des fenêtres mémoires ne sont plus contigüs. Cela nous permet de redimensionner les segments comme un tableau dynamique classique.</p>
<p>Néanmoins, cette opération est collective, ce qui contamine la plupart des méthodes de l'implémentation.</p>
<h2><a class="anchor" id="arcanedoc_parallel_shmem_var_usage"></a>
Utilisation</h2>
<p>Cette partie est gérée par la classe <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html" title="Classe permettant de créer une fenêtre mémoire partagée entre les sous-domaines d&#39;un même noeud.">Arcane::DynamicMachineMemoryWindow</a>.</p>
<p>Comme pour la précédente implémentation, celle-ci est compatible avec tous les modes de parallélisme de Arcane.</p>
<p>La création d'un objet de ce type est collectif. Une instance de cette classe va créer une fenêtre mémoire composée de plusieurs segments (un par sous-domaine).</p>
<p>Comme un UniqueArray, il est possible de spécifier une taille initiale (ici <code>5</code>) : </p><div class="fragment"><div class="line">    <a class="code hl_class" href="../../dc/d5a/classArcane_1_1IParallelMng.html">IParallelMng</a>* pm = m_parallel_mng;</div>
<div class="line">    <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> my_rank = pm-&gt;<a class="code hl_function" href="../../dc/d5a/classArcane_1_1IParallelMng.html#a26fc7494a02a7370d3be787fcc742b04">commRank</a>();</div>
<div class="line">    <a class="code hl_class" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html">DynamicMachineMemoryWindow&lt;Integer&gt;</a> window(pm, 5);</div>
<div class="line">    <a class="code hl_class" href="../../d9/d2e/classArcane_1_1ConstArrayView.html">ConstArrayView</a> machine_ranks(window.machineRanks());<span class="comment"></span></div>
</div><!-- fragment --><p>Et il est possible de ne pas spécifier de taille initiale. </p><div class="fragment"><div class="line">      <a class="code hl_class" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html">DynamicMachineMemoryWindow&lt;Integer&gt;</a> window2(pm);<span class="comment"></span></div>
</div><!-- fragment --><p>La méthode <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#a58ff41d9fcfa57cf5c2d9e963c2f6788" title="Méthode permettant d&#39;obtenir les rangs qui possèdent un segment dans la fenêtre.">Arcane::DynamicMachineMemoryWindow::machineRanks()</a> est disponible et renvoie le même tableau que l'implémentation <a class="el" href="../../d7/db6/classArcane_1_1MachineMemoryWindow.html" title="Classe permettant de créer une fenêtre mémoire partagée entre les sous-domaines d&#39;un même noeud....">Arcane::MachineMemoryWindow</a>.</p>
<p>Pour explorer notre segment ou le segment d'un autre sous-domaine, il est possible d'utiliser les mêmes méthodes que précédemment :</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <a class="code hl_class" href="../../d2/d5e/classArcane_1_1Span.html">Span</a> av_my_segment(window.segmentView());</div>
<div class="line">      <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> iter = 0;</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a>&amp; elem : av_my_segment) {</div>
<div class="line">        elem = iter * (my_rank + 1);</div>
<div class="line">        iter++;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    window.barrier();</div>
<div class="line">    <span class="keywordflow">for</span> (Int32 rank : machine_ranks) {</div>
<div class="line">      <a class="code hl_class" href="../../d2/d5e/classArcane_1_1Span.html">Span</a> av_segment(window.segmentConstView(rank));</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; 5; ++i) {</div>
<div class="line">        <span class="keywordflow">if</span> (av_segment[i] != i * (rank + 1)) {</div>
<div class="line">          <a class="code hl_define" href="../../d0/d1e/ArcaneGlobal_8h.html#a9d85d5fb84c5371348dd56600999e564">ARCANE_FATAL</a>(<span class="stringliteral">&quot;Bad element in memory window -- Expected : {0} -- Found : {1}&quot;</span>, (i * (rank + 1)), av_segment[i]);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }<span class="comment"></span></div>
</div><!-- fragment --><p>En revanche, comme les segments ne sont pas contigüs, les méthodes <code>windowView()</code> ne sont pas disponibles.</p>
<p>Les segments ont une taille qui peut être augmentée ou diminuée au cours du temps.</p>
<p>Il est possible d'ajouter des éléments avec la méthode <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#a162b38bb9545c851b0e01135acdd36be" title="Méthode permettant d&#39;ajouter des élements dans notre segment.">Arcane::DynamicMachineMemoryWindow::add(Arcane::Span&lt;const Type&gt;
elem)</a> :</p>
<div class="fragment"><div class="line">    <a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> pos_in_machine_ranks = -1;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; machine_ranks.size(); ++i) {</div>
<div class="line">      <span class="keywordflow">if</span> (my_rank == machine_ranks[i]) {</div>
<div class="line">        pos_in_machine_ranks = i;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Remarque : ici, pos_in_machine_ranks correspond au rang du processus</span></div>
<div class="line">    <span class="comment">// dans le communicateur MPI &quot;machine&quot;.</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_class" href="../../da/d0a/classArcane_1_1UniqueArray.html">UniqueArray&lt;Integer&gt;</a> buf;</div>
<div class="line">      <span class="keywordflow">if</span> (pos_in_machine_ranks == 0) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; 10; ++i) {</div>
<div class="line">          buf.<a class="code hl_function" href="../../d1/dfb/classArcane_1_1Array.html#aa57126075894e5b3579b22462ca49a96">add</a>(i);</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      window.add(buf);</div>
<div class="line">    }<span class="comment"></span></div>
</div><!-- fragment --><p>Cette méthode est collective, tous les sous-domaines d'un noeud doivent l'appeler. Si un sous-domaine ne souhaite pas ajouter d'éléments dans son segment, il peut appeler la méthode <code>add()</code> avec un tableau vide ou sans argument (<a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#a5ee065e2d4b950a4104a6e20be41e0a1" title="Méthode à appeler par le ou les sous-domaines ne souhaitant pas ajouter d&#39;éléments dans son segment.">Arcane::DynamicMachineMemoryWindow::add()</a>).</p>
<p>Cette opération peut être couteuse à cause de la réallocation mémoire. Il est donc conseillé d'ajouter une grande quantité d'éléments en une fois plutôt qu'élément par élément.</p>
<p>Si l'ajout élément par élément est indispensable, la méthode <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#acf6b06a0d542c8038d1dac9c4caf15f0" title="Méthode permettant de réserver de l&#39;espace mémoire dans notre segment.">Arcane::DynamicMachineMemoryWindow::reserve(Arcane::Int64 new_capacity)</a> est disponible afin d'éviter de réallouer plusieurs fois un segment :</p>
<div class="fragment"><div class="line">    window.reserve(20);<span class="comment"></span></div>
</div><!-- fragment --><p>Dans ce bout de code, on va réserver un espace de <code>20</code> <code>Integer</code> pour tous les sous-domaines. Cette valeur peut être différente pour chaque sous-domaine (si un sous-domaine ne veut pas réserver plus d'espace, il peut appeler <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#a2cb0ab20d94a1e5a69745bceada52f9b" title="Méthode à appeler par le ou les sous-domaines ne souhaitant pas réserver davantage de mémoire pour le...">Arcane::DynamicMachineMemoryWindow::reserve()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Avec cette méthode, on ne peut pas réserver moins d'espace que déjà réservé (appeler <code>reserve(0)</code> n'a aucun effet). Pour réduire l'espace réservé, la méthode <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#a8de2e6519ed40ede1dfd501d489212e4" title="Méthode permettant de réduire l&#39;espace mémoire réservé pour les segments au minimum nécessaire.">Arcane::DynamicMachineMemoryWindow::shrink()</a> est disponible.</dd></dl>
<dl class="section warning"><dt>Avertissement</dt><dd>Comme pour les UniqueArray, la méthode <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#acf6b06a0d542c8038d1dac9c4caf15f0" title="Méthode permettant de réserver de l&#39;espace mémoire dans notre segment.">Arcane::DynamicMachineMemoryWindow::reserve(Arcane::Int64
new_capacity)</a> n'a pas la même fonction que la méthode <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#a8b37664b3786b4d724e6980ae37e186e" title="Méthode permettant de redimensionner notre segment.">Arcane::DynamicMachineMemoryWindow::resize(Arcane::Int64
new_nb_elem)</a>. La première réserve uniquement l'espace mémoire mais cet espace reste inaccessible sans <code>add()</code> ou sans <code>resize()</code>. La seconde change le nombre d'éléments du segment et appelle <code>reserve()</code> si nécessaire.</dd></dl>
<div class="fragment"><div class="line">    window.resize(12);</div>
<div class="line">    info() &lt;&lt; window.segmentConstView().size();<span class="comment"></span></div>
</div><!-- fragment --><p>Dans notre exemple, <code>resize()</code> va augmenter le nombre d'éléments de tous les segments sauf du sous-domaine qui avait fait les <code>add()</code> précédemment (qui possède 15 éléments, contre 5 pour les autres). Ce sous-domaine va passer de 15 éléments à 12.</p>
<p>Comme pour la méthode <code>reserve()</code>, chaque sous-domaine peut mettre la valeur qu'il veut.</p>
<p>Il est aussi possible d'ajouter des éléments dans le segment d'un autre sous-domaine avec la méthode collective <a class="el" href="../../de/d8b/classArcane_1_1DynamicMachineMemoryWindow.html#afb71ffe9d0f65dda176ee5a9d1fa4045" title="Méthode permettant d&#39;ajouter des éléments dans le segment d&#39;un autre sous-domaine.">Arcane::DynamicMachineMemoryWindow::addToAnotherSegment(Arcane::Int32 rank, Arcane::Span&lt;const Type&gt; elem)</a>.</p>
<div class="fragment"><div class="line">    Int32 voisin = -1;</div>
<div class="line">    <span class="keywordflow">if</span> (my_rank % 2 == 0 &amp;&amp; pos_in_machine_ranks + 1 &lt; machine_ranks.size()) {</div>
<div class="line">      voisin = machine_ranks[pos_in_machine_ranks + 1];</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank % 2 == 1 &amp;&amp; pos_in_machine_ranks - 1 &gt;= 0) {</div>
<div class="line">      voisin = machine_ranks[pos_in_machine_ranks - 1];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On efface les éléments déjà présents dans les segments.</span></div>
<div class="line">    window.resize(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Si l&#39;on n&#39;a pas de voisins, on ajoute rien.</span></div>
<div class="line">    <span class="keywordflow">if</span> (voisin == -1) {</div>
<div class="line">      window.addToAnotherSegment();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      <a class="code hl_class" href="../../da/d0a/classArcane_1_1UniqueArray.html">UniqueArray&lt;Integer&gt;</a> buf;</div>
<div class="line">      <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../d0/d32/namespaceArcane.html#a45db9613d5b4bffe8397f823bf28a5b1">Integer</a> i = 0; i &lt; 10; ++i) {</div>
<div class="line">        buf.<a class="code hl_function" href="../../d1/dfb/classArcane_1_1Array.html#aa57126075894e5b3579b22462ca49a96">add</a>(my_rank);</div>
<div class="line">      }</div>
<div class="line">      window.addToAnotherSegment(voisin, buf);</div>
<div class="line">    }</div>
<div class="line">    info() &lt;&lt; <span class="stringliteral">&quot;Segment final : &quot;</span> &lt;&lt; window.segmentConstView();</div>
<div class="line">    window.shrink();<span class="comment"></span></div>
</div><!-- fragment --><dl class="section warning"><dt>Avertissement</dt><dd>Il est impossible de mélanger les appels à <code>add()</code> et à <code>addToAnotherSegment()</code>. Si un sous-domaine appelle la méthode <code>addToAnotherSegment()</code>, tous les sous-domaines devront appeler collectivement <code>addToAnotherSegment()</code> (avec ou sans paramètres) et non <code>add()</code>.</dd></dl>
<p>Le fonctionnement est presque identique à la méthode <code>add()</code> mais avec un paramètre en plus pour désigner le rang du sous-domaine possédant le segment à modifier.</p>
<dl class="section warning"><dt>Avertissement</dt><dd>Deux sous-domaines ne peuvent pas ajouter d'éléments dans un même segment (en une fois) (ce qui permet d'éviter les problèmes de concurrences). <div class="fragment"><div class="line"><span class="comment">// Pas possible :</span></div>
<div class="line"><span class="keywordflow">if</span> (my_rank == 0){</div>
<div class="line">  window.addToAnotherSegment();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank == 1){</div>
<div class="line">  window.addToAnotherSegment(0, mon_tableau);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank == 2){</div>
<div class="line">  window.addToAnotherSegment(0, mon_tableau);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Possible :</span></div>
<div class="line"><span class="keywordflow">if</span> (my_rank == 0){</div>
<div class="line">  window.addToAnotherSegment();</div>
<div class="line">  window.addToAnotherSegment();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank == 1){</div>
<div class="line">  window.addToAnotherSegment();</div>
<div class="line">  window.addToAnotherSegment(0, mon_tableau);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank == 2){</div>
<div class="line">  window.addToAnotherSegment(0, mon_tableau);</div>
<div class="line">  window.addToAnotherSegment();</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="arcanedoc_parallel_shmem_shmem"></a>
Mémoire partagée entre processus</h1>
<p>La mémoire partagée entre processus ne doit pas être vu comme la mémoire partagée en multithread. Ce partage n'est fait que sur une partie de la mémoire, pas sur toute la mémoire.</p>
<p>Prenons cette structure :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MaStruct</div>
<div class="line">{</div>
<div class="line">    MaStruct()</div>
<div class="line">    : array_integer(10)</div>
<div class="line">    {}</div>
<div class="line">    </div>
<div class="line">    UniqueArray&lt;Integer&gt; array_integer;</div>
<div class="line">};</div>
</div><!-- fragment --><p>On peut l'utiliser comme ceci :</p>
<div class="fragment"><div class="line">MaStruct ma_struct;</div>
<div class="line">ma_struct.array_integer[0] = 123 * (my_rank+1);</div>
</div><!-- fragment --><p>Si on utilise cette structure dans une fenêtre, ça donnerait :</p>
<div class="fragment"><div class="line">MachineMemoryWindow&lt;MaStruct&gt; win_struct(pm, 1);</div>
<div class="line">Span&lt;MaStruct&gt; my_span = win_struct.segmentView();</div>
<div class="line"><span class="keyword">new</span> (my_span.data()) MaStruct();</div>
<div class="line"> </div>
<div class="line">my_span[0].array_integer[0] = 123 * (my_rank+1);</div>
</div><!-- fragment --><p>On peut afficher la valeur que l'on a attribuée, ça fonctionne correctement :</p>
<div class="fragment"><div class="line">debug() &lt;&lt; <span class="stringliteral">&quot;Elem : &quot;</span> &lt;&lt; my_span[0].array_integer[0];</div>
</div><!-- fragment --><p>Mais si on veut afficher la valeur d'un autre processus :</p>
<div class="fragment"><div class="line">window.barrier();</div>
<div class="line"> </div>
<div class="line">Span&lt;MaStruct&gt; other_span = win_struct.segmentView(machine_ranks[(my_rank + 1) % machine_nb_proc]);</div>
<div class="line">debug() &lt;&lt; <span class="stringliteral">&quot;Elem : &quot;</span> &lt;&lt; other_span[0].array_integer[0];</div>
<div class="line"> </div>
<div class="line">my_span[0].~MaStruct();</div>
</div><!-- fragment --><p>En multi-processus (lancement avec <code>mpirun -n 2 ...</code>), le programme va planter (segfault), alors qu'il ne plantera pas en multithreading (lancement avec <code>-A,S=2</code>).</p>
<p>En multi-processus, les attributs du tableau <code>UniqueArray&lt;Integer&gt; array_integer;</code> de la structure ne sont pas alloués en mémoire partagée (les <code>new</code> ou <code>malloc</code> sont faits sur la mémoire locale), les autres processus n'y ont donc pas accès.</p>
<p>Il est aussi important de noter qu'un même emplacement mémoire en mémoire partagée est adressé différemment entre les processus. Donc, si l'on donne un allocateur en mémoire partagée à l'<code>UniqueArray</code>, les adresses utilisées seront valables uniquement localement.</p>
<hr  />
<div class="section_buttons"> <span class="back_section_button"> <a class="el" href="../../da/da2/arcanedoc_parallel_loadbalance.html">Equilibrage de charge sur le maillage</a> </span>   </div> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
  <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
      <li class="navelem"><a class="el" href="../../index.html">%Arcane</a></li><li class="navelem"><a class="el" href="../../df/d78/arcanedoc_parallel.html">Paralléliser un code</a></li>
      <li class="footer">Généré le Lundi 9 Février 2026 04:06:03 pour Arcane par <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
    </ul>
  </div>
  <script type="text/javascript" src="../../script-apply-config-theme.js"></script>
  <script type="text/javascript">
    // On met l'appel à cette fonction dans le footer dans le cas où
    // une page ne veut pas de personnalisation (changement de la 
    // variable globale "no_custom_theme").
    applyConfigWithCookies();
  </script>
</body>
</html>
