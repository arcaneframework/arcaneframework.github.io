<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Arcane: Premiers pas avec Arcane</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Arcane
   &#160;<span id="projectnumber">3.6.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Recherche');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Premiers pas avec <a class="el" href="../../d0/d32/namespaceArcane.html" title="-*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-">Arcane</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="arcanedoc_caseoptions_intro"></a>
Introduction</h1>
<p>TO BE DONE</p>
<h1><a class="anchor" id="Classes"></a>
utilitaires</h1>
<h2><a class="anchor" id="Chaînes"></a>
de caractères</h2>
<p>Il existe trois classes gérant les chaînes de caractères:</p><ul>
<li>String</li>
<li>CString</li>
<li>ConstCString</li>
</ul>
<h3><a class="anchor" id="La"></a>
classe 'String'</h3>
<p>La classe String est celle qui doit être utilisée prioritairement. Il s'agit d'une chaîne au format Unicode utilisant une sémantique de passage par valeur. Par exemple:</p>
<p>\begincode String s("Hello"); String s2(s); s += " world"; std::cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; '<br  />
'; </p>
<p>Alors s2 contient 'Hello' et s contient 'Hello world'. L'implémentation optimise la mémoire de telle sorte que la ligne 2 ne fait pas de copie de <em>s</em> mais contient juste une référence.</p>
<p>ATTENTION: en point important à noter est le constructeur String(const char* str) ne fait pas de copie de <em>str</em>. Si on souhaite une copie, il faut utiliser le constructeur String(const char* str,bool alloc). Par exemple, le code suivant est invalide:</p>
<p>\begincode String f() { std::string s("titi"); String s2(s.c_str()); return s2; } </p>
<p>Comme <code>'s.c_str()'</code> est local à la fonction, sa valeur stockée dans <em>s2</em> devient invalide dès qu'on quitte cette dernière. Il faut utiliser:</p>
<p>\begincode String f() { std::string s("titi"); String s2(s.c_str(),true); return s2; } </p>
<p>Ce genre de code ne devrait pas être fréquent et cette fonctionnalité permet d'utiliser les chaînes de caractères C classique de manière très performante.</p>
<h3><a class="anchor" id="La"></a>
classe 'String'</h3>
<p>La classe 'CString' correspond à une chaîne de caractère C classique mais avec une gestion mémoire intégrée. Elle est similaire à la classe standard std::string. Cette classe est encore utilisée dans <a class="el" href="../../d0/d32/namespaceArcane.html" title="-*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-">Arcane</a> mais est progressivement remplacer par la classe 'String'. Si possible, utiliser cette dernière à la place de 'CString'.</p>
<h3><a class="anchor" id="La"></a>
classe 'String'</h3>
<p>Cette classe encapsule un <code>'const</code> char*' et une longueur. Elle ne gère aucune mémoire et peut être utiliser en argument ou en retour de fonction partout ou est attentu une <code>'const</code> char*' classique. Comme elle ne fait aucune allocation, il ne faut jamais utiliser cette classe pour stocker de manière permantent une valeur, comme par exemple un champ d'une classe.</p>
<p>Une utilisation valide est par exemple:</p>
<p>\begincode void printString(ConstCString cs) { std::cout &lt;&lt; "S=" &lt;&lt; cs &lt;&lt; '<br  />
'; } std::string s1("titi"); const char* s2("toto"); String s3("tata"); printString(s1.c_str()); printString(s2); printString(s3.local()); </p>
<h1><a class="anchor" id="Utilisation"></a>
des tableaux</h1>
<p>Il existe plusieurs classes pour gérer les tableaux:</p><ul>
<li>CArrayT</li>
<li>BufferT</li>
<li>CArrayBaseT</li>
<li>ConstCArrayT</li>
</ul>
<p>Les classes <em>CArrayT</em> et <em>BufferT</em> sont similaires à la classe std::vector de la STL mais sont instrumentées pour détecter en mode vérification les débordement de tableaux et les allocations mémoire. En interne, ces deux classes gèrent des tableaux C alloués dynamiquement. La différence entre les deux classes est que le BufferT peut avoir une taille mémoire allouée (BufferT::capacity()) différente du nombre d'éléments du tableau (BufferT::size()). De plus, il possède aussi une méthode <a class="el" href="../../d8/d68/namespaceArcane_1_1math.html#af75b3ca6a0540e52218f747f910ee866" title="Ajoute le tableau copy_array dans l&#39;instance.">BufferT::add()</a> permettant d'ajouter un élément au tableau.</p>
<p>La classe ConstCArrayT est similaire à la classe ConstCString et stocke un pointeur sur un tableau et un nombre d'éléments. Il s'agit uniquement d'une référence et par conséquent, comme les ConstCString, cette reférence ne doit pas être stockée de manière permanente, car elle devient invalide si le tableau auquel elle fait référence est réalloué. Un ConstCArrayT ne permet pas de modifier les valeurs des éléments.</p>
<p>La classe CArrayBase est similaire à la classe ConstCArray, sauf qu'elle autorise de modifier les valeurs des éléments.</p>
<p>Les classes CArrayT et BufferT sont convertibles directement en CArrayBase ou ConstCArrayT.</p>
<p>NOTE: les classes sont en cours de réorganisation dans <a class="el" href="../../d0/d32/namespaceArcane.html" title="-*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-">Arcane</a>. A terme, il y aura fusion de 'CArray' et 'Buffer'. La classe conservée sera BufferT. De plus, CArrayBaseT sera renommée MutableCArrayT.</p>
<p>Un exemple d'utilisation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T sum(ConstCArrayT&lt;T&gt; v)</div>
<div class="line">{</div>
<div class="line">  T sum = T();</div>
<div class="line">  <span class="keywordflow">for</span>( Integer i=0, is=v.size(); i&lt;is; ++i ){</div>
<div class="line">    sum += v[i];</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> inc(CArrayBaseT&lt;T&gt; v)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span>( Integer i=0, is=v.size(); i&lt;is; ++i ){</div>
<div class="line">    ++v[i];</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">   BufferT&lt;Integer&gt; z;</div>
<div class="line">   z.add(5);</div>
<div class="line">   z.add(7);</div>
<div class="line">   std::cout &lt;&lt; sum(z) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">   CArrayT&lt;Integer&gt; z2;</div>
<div class="line">   z2.resize(3);</div>
<div class="line">   z2[0] = z2[1] = z2[2] = 5;</div>
<div class="line">   inc(z2);</div>
<div class="line">   std::vector&lt;Integer&gt; z3;</div>
<div class="line">   z3.resize(3);</div>
<div class="line">   z3[0] = z3[1] = z3[2] = 5;</div>
<div class="line">   inc(z3);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré le Lundi 16 Mai 2022 03:16:00 pour Arcane par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
