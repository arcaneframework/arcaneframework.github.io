<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Arcane: Vectorisation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Arcane
   &#160;<span id="projectnumber">3.7.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Recherche','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Vectorisation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table des matières</h3>
<ul><li class="level1"><a href="#arcanedoc_simd_intro">Introduction</a></li>
<li class="level1"><a href="#arcanedoc_simd_usage">Utilisation des classes vectorielles</a><ul><li class="level2"><a href="#arcanedoc_simd_alignment">Gestion de l&#39;alignement</a></li>
<li class="level2"><a href="#arcanedoc_simd_endloop">Gestion des fins de boucle</a></li>
<li class="level2"><a href="#arcanedoc_simd_operation">Opérations supportées</a></li>
<li class="level2"><a href="#arcanedoc_simd_support">Mécanismes de vectorisation supportés</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md____w_arcaneframework_github_io_arcaneframework_github_io_framework_arcane_doc_simd"></a></p>
<h1><a class="anchor" id="arcanedoc_simd_intro"></a>
Introduction</h1>
<p>La vectorisation est un mécanisme permettant d'exécuter la même instruction sur plusieurs données. Le terme anglais couramment utilisé pour qualifier la vectorisation est <b>Single Instruction Multiple Data (SIMD)</b>. Comme il s'agit d'une instruction gérée directement par le processeur, les opérations possibles sont assez limitées. En général, il s'agit des opérations arithmétiques de base (addition, soustraction, ...) ainsi que les fonctions mathématiques classiques (minimum, maximum, valeur absolue, ...). Les opérations mathématiques complexes (comme le logarithme, l'exponentielle, ...) ne sont en général pas des instructions natives vectorielles.</p>
<p>Les processeurs récents permettent tous de faire de la vectorisation. Par contre, les tailles de vecteur et les opérations possibles sont différentes d'un processeur à l'autre.</p>
<p>Par exemple, la boucle simple suivante effectue <b>n</b> additions:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line">UniqueArray&lt;Real&gt; a, b, c;</div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;n; ++i ){</div>
<div class="line">  a[i] = b[i] + c[i];</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceArcane_html"><div class="ttname"><a href="../../d0/d32/namespaceArcane.html">Arcane</a></div><div class="ttdoc">-*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-</div><div class="ttdef"><b>Definition:</b> AbstractCaseDocumentVisitor.cc:20</div></div>
</div><!-- fragment --><p>Avec un processeur scalaire, les registres ne contiennent qu'un seul réel et les instructions d'addition opèrent donc sur un seul réel. Il faudra <b>n</b> instructions d'addition pour faire ce calcul. Un processeur vectoriel dispose de registres contenant plusieurs réels. Pour des registres contenant <b>P</b> réels, le nombre d'instructions d'addition nécessaire est donc <b>n/P</b>. Si les instructions scalaires et vectorielles prennent le même temps, on a donc une accélération théorique d'un facteur <b>P</b>. Plus les registres sont grands, plus l'intêret potentiel de la vectorisation est important. Bien entendu, dans la pratique c'est souvent moins rose et le gain réel dépend d'autres facteurs comme la bande passante mémoire, le pipelining, ...</p>
<p>Pour exploiter la vectorisation, il existe deux possibilités (qui sont compatibles):</p>
<ul>
<li>laisser le compilateur gérer la vectorisation.</li>
<li>utiliser des classes C++ spécifiques concues pour cela.</li>
</ul>
<p>La première solution est la plus simple car elle ne nécessite pas de changer le code. Elle est directement disponible via les bonnes options du compilateur. La contrepartie de cette simplicité est qu'il est souvent difficile pour le compilateur de détecter les endroits où la vectorisation est possible. Le code généré est donc rarement vectorisé. La seconde méthode garantit l'exploitation de la vectorisation mais elle nécessite de réécrire le code. Arcane propose un ensemble de classes pour exploiter cette seconde méthode.</p>
<p>Le principe est donc de fournir une classe vectorielle correspondant à une classe scalaire. La classe vectorielle contiendra donc <em>N</em> valeurs scalaires, avec <em>N</em> dépendant du type de vectorisation disponible.</p>
<p>Même si en théorie la vectorisation peut s'appliquer sur tous les types simples (short, int, long, float, ...), on se limite dans Arcane à fournir des classes gérant la vectorisation que pour les types Arcane::Real et dérivés (<a class="el" href="../../d6/d24/classArcane_1_1Real2.html" title="Classe gérant un vecteur de réel de dimension 2.">Arcane::Real2</a>, <a class="el" href="../../d1/da6/classArcane_1_1Real3.html" title="Classe gérant un vecteur de réel de dimension 3.">Arcane::Real3</a>).</p>
<p>Actuellement, Arcane fournit les types vectoriels suivants:</p>
<table class="doxtable">
<tr>
<th>Type scalaire </th><th>Type vectoriel </th><th>Fichier de définition  </th></tr>
<tr>
<td>Arcane::Real </td><td><a class="el" href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e" title="Vecteur SIMD de réel.">Arcane::SimdReal</a> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d6/dea/Simd_8h.html">arcane/utils/Simd.h</a>&quot;</span></div>
<div class="ttc" id="aSimd_8h_html"><div class="ttname"><a href="../../d6/dea/Simd_8h.html">Simd.h</a></div></div>
</div><!-- fragment -->  </td></tr>
<tr>
<td><a class="el" href="../../d6/d24/classArcane_1_1Real2.html" title="Classe gérant un vecteur de réel de dimension 2.">Arcane::Real2</a> </td><td><a class="el" href="../../d4/d7a/classArcane_1_1SimdReal2.html" title="Représente un Real2 vectoriel.">Arcane::SimdReal2</a> </td><td></td></tr>
<tr>
<td><a class="el" href="../../d1/da6/classArcane_1_1Real3.html" title="Classe gérant un vecteur de réel de dimension 3.">Arcane::Real3</a> </td><td><a class="el" href="../../d2/d63/classArcane_1_1SimdReal3.html" title="Représente un Real3 vectoriel.">Arcane::SimdReal3</a> </td><td></td></tr>
<tr>
<td><a class="el" href="../../df/d5f/classArcane_1_1Item.html" title="Classe de base d&#39;un élément de maillage.">Arcane::Item</a>, <a class="el" href="../../d9/db2/classArcane_1_1Cell.html" title="Maille d&#39;un maillage.">Arcane::Cell</a>, <a class="el" href="../../d1/db1/classArcane_1_1Face.html" title="Face d&#39;une maille.">Arcane::Face</a>, ... </td><td><a class="el" href="../../d5/d75/classArcane_1_1SimdItem.html" title="Gère un vecteur d&#39;entité Item.">Arcane::SimdItem</a>, <a class="el" href="../../d5/d04/group__ArcaneSimd.html#ga1fa29db17212b77758a93b80957fe001" title="Vecteur SIMD de Cell.">Arcane::SimdCell</a>, <a class="el" href="../../d5/d04/group__ArcaneSimd.html#ga96c9290f4544f880ad7a710b6226f36d" title="Vecteur SIMD de Face.">Arcane::SimdFace</a>, ... </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../de/d2d/SimdItem_8h.html">arcane/SimdItem.h</a>&quot;</span></div>
<div class="ttc" id="aSimdItem_8h_html"><div class="ttname"><a href="../../de/d2d/SimdItem_8h.html">SimdItem.h</a></div></div>
</div><!-- fragment -->   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Pour l'instant, les classes Real2x2 et Real3x3 ne disposent pas d'une classe vectorielle associée mais cela sera disponible dans une version ultérieure de Arcane.</dd></dl>
<h1><a class="anchor" id="arcanedoc_simd_usage"></a>
Utilisation des classes vectorielles</h1>
<p>L'utilisation des classes SIMD est similaire à l'usage scalaire. Il suffit en général de changer le nom des classes scalaires par le nom vectoriel correspondant.</p>
<dl class="section note"><dt>Note</dt><dd>L'utilisation de la vectorisation suppose l'utilisation des vues sur les variables. Il n'est pas possible d'accéder directement à une variable via les classes <a class="el" href="../../d5/d75/classArcane_1_1SimdItem.html" title="Gère un vecteur d&#39;entité Item.">Arcane::SimdItem</a> et dérivées.</dd></dl>
<p>L'exemple suivant montre comment passer d'une écriture scalaire à une écriture vectorielle:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Déclaration des variables</span></div>
<div class="line"><a class="code" href="../../d3/d00/group__Variable.html#ga135a2515548fbcacb89c3ce1a2410b79">VariableCellReal</a> pressure = ...;</div>
<div class="line"><a class="code" href="../../d3/d00/group__Variable.html#ga135a2515548fbcacb89c3ce1a2410b79">VariableCellReal</a> density = ...;</div>
<div class="line"><a class="code" href="../../d3/d00/group__Variable.html#ga135a2515548fbcacb89c3ce1a2410b79">VariableCellReal</a> adiabatic_cst = ...;</div>
<div class="line"><a class="code" href="../../d3/d00/group__Variable.html#ga135a2515548fbcacb89c3ce1a2410b79">VariableCellReal</a> internal_energy = ...;</div>
<div class="line"><a class="code" href="../../d3/d00/group__Variable.html#ga135a2515548fbcacb89c3ce1a2410b79">VariableCellReal</a> sound_speed = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vues en entrée (lecture)</span></div>
<div class="line"><span class="comment">// En C++11, il est aussi possible d&#39;utiliser le mot clé &#39;auto&#39;:</span></div>
<div class="line"><span class="comment">// auto in_pressure = viewIn(pressure);</span></div>
<div class="line">VariableCellRealInView in_pressure = <a class="code" href="../../d0/d32/namespaceArcane.html#a1bfa4b61027e320561d2e982c43c94db">viewIn</a>(pressure);</div>
<div class="line">VariableCellRealInView in_density = <a class="code" href="../../d0/d32/namespaceArcane.html#a1bfa4b61027e320561d2e982c43c94db">viewIn</a>(m_density);</div>
<div class="line">VariableCellRealInView in_adiabatic_cst = <a class="code" href="../../d0/d32/namespaceArcane.html#a1bfa4b61027e320561d2e982c43c94db">viewIn</a>(adiabatic_cst);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vues en sortie (écriture)</span></div>
<div class="line">VariableCellRealOutView out_internal_energy = <a class="code" href="../../d0/d32/namespaceArcane.html#a6ceea9fd1d9ac58ef8df875826f589f3">viewOut</a>(internal_energy);</div>
<div class="line">VariableCellRealOutView out_sound_speed = <a class="code" href="../../d0/d32/namespaceArcane.html#a6ceea9fd1d9ac58ef8df875826f589f3">viewOut</a>(sound_speed);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Version scalaire</span></div>
<div class="line"><a class="code" href="../../d6/d0f/ItemEnumerator_8h.html#aaf5910d68ad8428248f844535ab071f3">ENUMERATE_CELL</a>(icell,allCells()){</div>
<div class="line">  Cell vi = *icell;</div>
<div class="line">  Real pressure = in_pressure[vi];</div>
<div class="line">  Real adiabatic_cst = in_adiabatic_cst[vi];</div>
<div class="line">  Real density = in_density[vi];</div>
<div class="line">  out_internal_energy[vi] = pressure / ((adiabatic_cst-1.0) * density);</div>
<div class="line">  out_sound_speed[vi] = <a class="code" href="../../d8/d68/namespaceArcane_1_1math.html#ae6722a616f091a53b80d6ffa44d325a3">math::sqrt</a>(adiabatic_cst*pressure/density);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Version vectorielle</span></div>
<div class="line"><a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga0a9dc0b44f6c0935eefd6947014c937f">ENUMERATE_SIMD_CELL</a>(icell,allCells()){</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga1fa29db17212b77758a93b80957fe001">SimdCell</a> vi = *icell;</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e">SimdReal</a> pressure = in_pressure[vi];</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e">SimdReal</a> adiabatic_cst = in_adiabatic_cst[vi];</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e">SimdReal</a> density = in_density[vi];</div>
<div class="line">  out_internal_energy[vi] = pressure / ((adiabatic_cst-1.0) * density);</div>
<div class="line">  out_sound_speed[vi] = <a class="code" href="../../d8/d68/namespaceArcane_1_1math.html#ae6722a616f091a53b80d6ffa44d325a3">math::sqrt</a>(adiabatic_cst*pressure/density);</div>
<div class="line">}</div>
<div class="ttc" id="aItemEnumerator_8h_html_aaf5910d68ad8428248f844535ab071f3"><div class="ttname"><a href="../../d6/d0f/ItemEnumerator_8h.html#aaf5910d68ad8428248f844535ab071f3">ENUMERATE_CELL</a></div><div class="ttdeci">#define ENUMERATE_CELL(name, group)</div><div class="ttdoc">Enumérateur générique d'un groupe de mailles.</div><div class="ttdef"><b>Definition:</b> ItemEnumerator.h:260</div></div>
<div class="ttc" id="agroup__ArcaneSimd_html_ga0a9dc0b44f6c0935eefd6947014c937f"><div class="ttname"><a href="../../d5/d04/group__ArcaneSimd.html#ga0a9dc0b44f6c0935eefd6947014c937f">ENUMERATE_SIMD_CELL</a></div><div class="ttdeci">#define ENUMERATE_SIMD_CELL(name, group)</div><div class="ttdoc">Enumérateur SIMD sur un groupe ou liste de mailles.</div><div class="ttdef"><b>Definition:</b> SimdItem.h:473</div></div>
<div class="ttc" id="agroup__ArcaneSimd_html_ga1fa29db17212b77758a93b80957fe001"><div class="ttname"><a href="../../d5/d04/group__ArcaneSimd.html#ga1fa29db17212b77758a93b80957fe001">Arcane::SimdCell</a></div><div class="ttdeci">SimdItemT&lt; Cell &gt; SimdCell</div><div class="ttdoc">Vecteur SIMD de Cell.</div><div class="ttdef"><b>Definition:</b> SimdItem.h:431</div></div>
<div class="ttc" id="agroup__ArcaneSimd_html_ga5aa9d2a778e46ece234ee1dbf469a04e"><div class="ttname"><a href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e">Arcane::SimdReal</a></div><div class="ttdeci">SimdInfo::SimdReal SimdReal</div><div class="ttdoc">Vecteur SIMD de réel.</div><div class="ttdef"><b>Definition:</b> Simd.h:134</div></div>
<div class="ttc" id="agroup__Variable_html_ga135a2515548fbcacb89c3ce1a2410b79"><div class="ttname"><a href="../../d3/d00/group__Variable.html#ga135a2515548fbcacb89c3ce1a2410b79">Arcane::VariableCellReal</a></div><div class="ttdeci">MeshVariableScalarRefT&lt; Cell, Real &gt; VariableCellReal</div><div class="ttdoc">Grandeur au centre des mailles de type réel.</div><div class="ttdef"><b>Definition:</b> VariableTypedef.h:290</div></div>
<div class="ttc" id="anamespaceArcane_1_1math_html_ae6722a616f091a53b80d6ffa44d325a3"><div class="ttname"><a href="../../d8/d68/namespaceArcane_1_1math.html#ae6722a616f091a53b80d6ffa44d325a3">Arcane::math::sqrt</a></div><div class="ttdeci">ARCCORE_HOST_DEVICE double sqrt(double v)</div><div class="ttdoc">Racine carrée de v.</div><div class="ttdef"><b>Definition:</b> Math.h:133</div></div>
<div class="ttc" id="anamespaceArcane_html_a1bfa4b61027e320561d2e982c43c94db"><div class="ttname"><a href="../../d0/d32/namespaceArcane.html#a1bfa4b61027e320561d2e982c43c94db">Arcane::viewIn</a></div><div class="ttdeci">MatItemVariableScalarInViewT&lt; Cell, DataType &gt; viewIn(const CellMaterialVariableScalarRef&lt; DataType &gt; &amp;var)</div><div class="ttdoc">Vue en lecture.</div><div class="ttdef"><b>Definition:</b> ComponentSimd.h:349</div></div>
<div class="ttc" id="anamespaceArcane_html_a6ceea9fd1d9ac58ef8df875826f589f3"><div class="ttname"><a href="../../d0/d32/namespaceArcane.html#a6ceea9fd1d9ac58ef8df875826f589f3">Arcane::viewOut</a></div><div class="ttdeci">MatItemVariableScalarOutViewT&lt; Cell, DataType &gt; viewOut(CellMaterialVariableScalarRef&lt; DataType &gt; &amp;var)</div><div class="ttdoc">Vue en écriture.</div><div class="ttdef"><b>Definition:</b> ComponentSimd.h:361</div></div>
</div><!-- fragment --><p>La vectorisation fonctionne bien tant que tous les éléments du vecteur doivent effectuer la même opération. Les choses se compliquent lorsque cela n'est plus le cas. Notamment, tout ce qui dépend d'une condition est difficilement vectorisable. Il existe aussi des cas où on souhaite faire dans une boucle vectorielle des opérations spécifiques pour chacun des éléments. Pour gérer cette situation, il est possible d'ajouter des sections séquentiels en itérant sur les entités d'un <a class="el" href="../../d5/d75/classArcane_1_1SimdItem.html" title="Gère un vecteur d&#39;entité Item.">Arcane::SimdItem</a> via les macros ENUMERATE_*. Par exemple:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line"><a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga0a9dc0b44f6c0935eefd6947014c937f">ENUMERATE_SIMD_CELL</a>(ivcell,allCells()){</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga1fa29db17212b77758a93b80957fe001">SimdCell</a> simd_cell = *ivcell; <span class="comment">// Vecteur de mailles</span></div>
<div class="line">  <a class="code" href="../../d6/d0f/ItemEnumerator_8h.html#aaf5910d68ad8428248f844535ab071f3">ENUMERATE_CELL</a>(icell,ivcell){</div>
<div class="line">    Cell cell = *icell;</div>
<div class="line">    info() &lt;&lt; <span class="stringliteral">&quot;Cell: local_id=&quot;</span> &lt;&lt; cell.localId();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Enfin, il est possible de connaître le nombre de réels d'un registre vectoriel via la constante SimdReal::BLOCK_SIZE. Cela permet par exemple d'itérer sur les éléments d'un registre vectoriel:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line">SimdReal3 vr;</div>
<div class="line"><span class="keywordflow">for</span>( Integer i=0, n=SimdReal::BLOCK_SIZE; i&lt;n; ++i ){</div>
<div class="line">  Real3 r = vr[i];</div>
<div class="line">  info() &lt;&lt; <span class="stringliteral">&quot; R [&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; r;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="arcanedoc_simd_alignment"></a>
Gestion de l'alignement</h2>
<p>En général, et c'est le cas pour les processeurs x64, l'utilisation de la vectorisation nécessite que les données en mémoires soient alignées d'une manière plus restrictive que pour types scalaires. Pour le SSE, l'AVX et l'AVX512 L'alignement minimal est égal à la taille en octet du vecteur Simd. Donc par exemple pour l'AVX avec des vecteurs de 256 bits, soit 32 octets, l'alignement minimal est de 32 octets. Pour simplifier la vectorisation Arcane garantit que les types suivants ont l'alignement minimal souhaité pour la vectorisation:</p><ul>
<li>les localIds() des <a class="el" href="../../d9/d27/classArcane_1_1ItemGroup.html" title="Groupe d&#39;entités de maillage.">Arcane::ItemGroup</a>.</li>
<li>les données des variables tableaux et scalaires sur le maillage.</li>
<li>les données des variables tableaux 2D et variables tableaux sur le maillage. A noter que pour ces dernières le début du tableau est aligné mais si la première dimension n'est pas un multiple de la taille du vecteur alors les éléments suivants ne seront pas alignés car il n'y a pas encore de gestion du padding).</li>
</ul>
<p>Le C++ ne permettant pas d'allouer via new/delete avec alignement, Arcane fournit la classe <a class="el" href="../../d0/d7e/classArccore_1_1AlignedMemoryAllocator.html" title="Allocateur mémoire avec alignement mémoire spécifique.">Arccore::AlignedMemoryAllocator</a> qui peut être utilisée avec les classes Arcane::UniqueArray et Arcane::SharedArray pour garantir l'alignement. Par exemple:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line">UniqueArray x(<a class="code" href="../../d0/d7e/classArccore_1_1AlignedMemoryAllocator.html#aa36776272470f04a8ed1a6245aed27e4">AlignedMemoryAllocator::Simd</a>());</div>
<div class="line">x.resize(32); <span class="comment">// Garanti que \a x à un alignement correct.</span></div>
<div class="ttc" id="aclassArccore_1_1AlignedMemoryAllocator_html_aa36776272470f04a8ed1a6245aed27e4"><div class="ttname"><a href="../../d0/d7e/classArccore_1_1AlignedMemoryAllocator.html#aa36776272470f04a8ed1a6245aed27e4">Arccore::AlignedMemoryAllocator::Simd</a></div><div class="ttdeci">static AlignedMemoryAllocator * Simd()</div><div class="ttdoc">Allocateur garantissant l'alignement pour utiliser la vectorisation sur la plateforme cible.</div><div class="ttdef"><b>Definition:</b> arccore/src/collections/arccore/collections/IMemoryAllocator.h:187</div></div>
</div><!-- fragment --><h2><a class="anchor" id="arcanedoc_simd_endloop"></a>
Gestion des fins de boucle</h2>
<p>La vectorisation fonctionne bien lorsque le nombre d'éléments de la boucle est un multiple de la taille du vecteur Simd. Si ce n'est pas le cas, il faut traiter la dernière partie de la boucle d'une certaine manière. <b>Afin d'offrir un mécanisme identique pour toute les types de vectorisation, Arcane duplique dans le vecteur Simd la dernière valeur valide</b>. Par exemple, on suppose le code suivant:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line"><a class="code" href="../../de/db5/group__Mesh.html#ga4d78be302ffdabc4e0f16578cc077314">CellGroup</a> cells = ...</div>
<div class="line">ENUMERATE_SIMD_CELL(ivcell,cells){</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga1fa29db17212b77758a93b80957fe001">SimdCell</a> simd_cell = *ivcell; <span class="comment">// Vecteur de mailles</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__Mesh_html_ga4d78be302ffdabc4e0f16578cc077314"><div class="ttname"><a href="../../de/db5/group__Mesh.html#ga4d78be302ffdabc4e0f16578cc077314">Arcane::CellGroup</a></div><div class="ttdeci">ItemGroupT&lt; Cell &gt; CellGroup</div><div class="ttdoc">Groupe de mailles.</div><div class="ttdef"><b>Definition:</b> ItemTypes.h:142</div></div>
</div><!-- fragment --><p>Avec <em>cells</em> un groupe de mailles qui contient 11 éléments. Si on suppose que la taille d'un vecteur est 8, alors la boucle précédent fera deux itérations. Pour la première on aura les valeurs suivantes de <em>simd_cell</em> </p>
<div class="fragment"><div class="line"><span class="comment">// Première itération</span></div>
<div class="line">simd_cell[0]  = cells[0];</div>
<div class="line">simd_cell[1]  = cells[1];</div>
<div class="line">simd_cell[2]  = cells[2];</div>
<div class="line">simd_cell[3]  = cells[3];</div>
<div class="line">simd_cell[4]  = cells[4];</div>
<div class="line">simd_cell[5]  = cells[5];</div>
<div class="line">simd_cell[6]  = cells[6];</div>
<div class="line">simd_cell[7]  = cells[7];</div>
</div><!-- fragment --><p>Pour la deuxième itération, comme <em>cells</em> ne contient que 11 éléments, on répète dans <em>simd_cell</em> la dernière valeur valide:</p>
<div class="fragment"><div class="line"><span class="comment">// Deuxième itération</span></div>
<div class="line">simd_cell[8]  = cells[8];</div>
<div class="line">simd_cell[9]  = cells[9];</div>
<div class="line">simd_cell[10] = cells[10];</div>
<div class="line">simd_cell[11] = cells[10]; <span class="comment">// Répète la dernière valeurs valide.</span></div>
<div class="line">simd_cell[12] = cells[10];</div>
<div class="line">simd_cell[13] = cells[10];</div>
<div class="line">simd_cell[14] = cells[10];</div>
<div class="line">simd_cell[15] = cells[10];</div>
</div><!-- fragment --><p>Ce mécanisme fonctionne partaitement tant que les opérations effectués sont bien vectorielles. Si ce n'est pas le cas, il est possible d'itérer uniquement sur les valeurs valides comme suit:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d32/namespaceArcane.html">Arcane</a>;</div>
<div class="line"><a class="code" href="../../de/db5/group__Mesh.html#ga4d78be302ffdabc4e0f16578cc077314">CellGroup</a> cells = ...</div>
<div class="line">ENUMERATE_SIMD_CELL(ivcell,cells){</div>
<div class="line">  <a class="code" href="../../d5/d04/group__ArcaneSimd.html#ga1fa29db17212b77758a93b80957fe001">SimdCell</a> simd_cell = *ivcell; <span class="comment">// Vecteur de mailles</span></div>
<div class="line">  <a class="code" href="../../d6/d0f/ItemEnumerator_8h.html#aaf5910d68ad8428248f844535ab071f3">ENUMERATE_CELL</a>(icell,ivcell){</div>
<div class="line">    Cell cell = *icell;</div>
<div class="line">    info() &lt;&lt; <span class="stringliteral">&quot;Cell: local_id=&quot;</span> &lt;&lt; cell.localId();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Avec l'exemple précédent, la boucle interne ne fera que 3 itérations, (pour les mailles <em>cells</em>[8], <em>cells</em>[9] et <em>cells</em>[10]) pour la dernière partie de <em>cells</em>.</p>
<h2><a class="anchor" id="arcanedoc_simd_operation"></a>
Opérations supportées</h2>
<p>Les opérations mathématiquees supportés par les classes vectorielles de Arcane sont définies dans le fichier <a class="el" href="../../df/d8d/SimdMathUtils_8h_source.html">SimdMathUtils.h</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;arcane/SimdMathUtils.h&quot;</span></div>
</div><!-- fragment --><p>Arcane fournit pour les classes vectorielles <a class="el" href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e" title="Vecteur SIMD de réel.">Arcane::SimdReal</a>, <a class="el" href="../../d4/d7a/classArcane_1_1SimdReal2.html" title="Représente un Real2 vectoriel.">Arcane::SimdReal2</a> et <a class="el" href="../../d2/d63/classArcane_1_1SimdReal3.html" title="Représente un Real3 vectoriel.">Arcane::SimdReal3</a> les mêmes opérations que celles disponibles dans <a class="el" href="../../dc/d3e/MathUtils_8h.html" title="Fonctions mathématiques diverses.">MathUtils.h</a> pour la version scalaire à l'exception de <em>min</em> et <em>max</em>.</p>
<h2><a class="anchor" id="arcanedoc_simd_support"></a>
Mécanismes de vectorisation supportés</h2>
<p>Dans la version 2.2, Arcane ne supporte que la vectorisation pour les processeurs d'architecture x86.</p>
<p>Pour ces processeurs, il existe (actuellement) trois générations de vectorisation:</p>
<ul>
<li>la vectorisation SSE, qui est disponible sur tous les processeurs 64 bits et qui utilisent des registres de 128 bits.</li>
<li>la vectorisation AVX, qui est disponible sur les processeurs depuis la génération SandyBridge (en gros depuis 2012). Ces vecteurs ont une taille de 256 bits.</li>
<li>la vectorisation AVX512, qui est disponible sur les processeurs de génération SkyLake (2015+) et qui dispose de vecteurs de 512 bits. Cette vectorisation est supportée depuis la version 2.3.9 de Arcane.</li>
</ul>
<p>Suivant la plateforme, plusieurs mécanismes peuvent être disponibles. Sur les processeurs Intel les processeurs ont une compatibilité ascendante et donc ceux qui supportent l'AVX512 supportent aussi l'AVX et le SSE. De même, les processeurs avec AVX supportent le SSE.</p>
<p>Arcane définit le mécanisme par défaut comme étant celui qui utilise la vectorisation la plus importante. Les types Arcane::SimdInfo, <a class="el" href="../../d5/d04/group__ArcaneSimd.html#ga5aa9d2a778e46ece234ee1dbf469a04e" title="Vecteur SIMD de réel.">Arcane::SimdReal</a>, <a class="el" href="../../d2/d63/classArcane_1_1SimdReal3.html" title="Représente un Real3 vectoriel.">Arcane::SimdReal3</a> sont donc des typedefs qui dépendent de la plateforme.</p>
<p>Arcane définit aussi des macros indiquant les mécanismes disponibles:</p>
<ul>
<li>ARCANE_HAS_SSE si la vectorisation avec SSE est disponible</li>
<li>ARCANE_HAS_AVX si la vectorisation avec AVX ou AVX2 est disponible</li>
<li>ARCANE_HAS_AVX512 si la vectorisation avec AVX512 est disponible. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré le Lundi 1 Août 2022 04:01:25 pour Arcane par&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
